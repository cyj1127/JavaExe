02.06
 * ArrayList 는 배열로 구성되어있다.
 * 다만 배열보다 나은 점은 데이터가 배열을 꽉 채우면 알아서 내부 공간을 늘려준다.
 * 그리고 <> 사이에 어떤 자료형을 넣느냐에 따라 해당 자료형을 저장할 수 있다.
 * 
 * List 인터페이스를 상속받았고 List 계열 클래스는 List 로 변수를 저장해서 사용한다.
 * 
 * 리스트의 가장 큰 특징은 '순서가 보장된다' > 같은 값을 두 번 넣어도 순서가 다르기에 등록이 잘 된다.
 * ArrayList의 가장 큰 특징은 내부가 배열로 이루어져있다는 것.
 * 다만, 배열의 크기를 자동으로 늘려준다.
 * 
 * --ArrayList 특징--
 *삽입, 삭제가 자주 일어나지 않거나 >> 중간 삽입시 모든 데이터를 뒤로 하나씩 미루고, 삭제시에 하나씩 전부 당김.
 *데이터의 양이 많지 않을 때 사용한다.
 *
 *But !! 데이터의 양이 많고, 읽기 전용인 경우 그리고 순차 검색인 경우는 가장 빠른 성능을 보여준다.
 *(쉽게 말해 변동 없이 단순히 출력만 해야하는 경우..)
*

---Vector---
/*ArrayList 와 동일하다
 * 다만 멀티스레드 환경에서 2개이상의 스레드가 동시접근할 때 안전하다
 * 1개 스레드일 때는 AryyayList보다 약간 성능 저하가 있다(동기화 처리때문)
 
 ---LinkedList---
 삽입/삭제가 빈번할 때 사용하면 좋다.(사진 참고)
 
 
 /*Set 은 집합이다.
 * 집합은 데이터의 모음일 뿐 '순서가 보장되지 않는다'
 * 그럼로 중복을 허용하지 않는다.
 * 데이터가 입력될 때 기존 데이터가 있는지 확인한다.
 * 이때 사용하는 알고리즘이 Hash 알고리즘이다.
 * Hash 는 패스워드 검증시에 사용한다.
 * Hash 는 검색속도가 굉장히 빠르다.
 *--List--에 저장시 중복 객체도 저장하고 입력받은 순서 그대로 저장 및 출력하게 된다.
 
 --hashCode--(그림 참조)
 1단계로 해시코드로 먼저 분류를 한다.
 해시코드가 다르다면 다른객체로 인식.
 혹시나 해시코드가 같아도 다른객체일 수 있기 때문에 equals 로 물리적인 주소값을 비교한다.
 (equals 는 부담되는 방식이에 해시코드로 먼저 대부분 분류를 한다.)
 -정확한 값(위치)을 갖고 있기 때문에 10억개 이던지 100억개 이던지 금방 찾을 수 있다.
 
 /*Member 객체의 내용(이름,나이)로 객체가 같은지 다른지 비교하기 위해서는
 * Object 로부터 상속받은 hashCode()와 equals()를 overriding 해야 한다.
 * overriding 하지 않으면 각각 객체의 해시값과 객체의 주소를 가지고 비교하지만
 * 아래처럼 overriding 하면 객체내의 필드 내용으로 비교한다.
 * 
 * 그러므로 주소록이나 이런 데이터를 저장할 때는 아래처럼 하는 것이 필요하다.
 * */
 /*웹 프로그래밍에서 환경설정 값을 파일에 보관하고
 * 상황에 따라 바꾼다
 * Java 프로그램에서는 이런 환경설정 파일을 읽어서
 * 처리해야 하는데
 * 이 때 외부 파일을 주로 *.properties 파일을 사용하고
 * 이 파일을 읽어드리는 용도로 Properties 클래스를 사용한다.*/
 
 02.07
 스택과 큐(그림 참조)
 -스택은 시간의 역순으로 꺼내고 싶을 때 사용한다.
 -큐는 입력한 그대로의 순서로 사용하고 싶을때 쓴다.
 
 Stack 에 넣을때는 push, 꺼낼 때는 pop 을 사용한다.
 Queue 에 넣을때는 offer 를 , 꺼낼 때는 poll 을 사용한다.
 Queue 는 인터페이스 이기 때문에 메서드만 제공한다.
 
 Array 에서 불변 컬렉션을 만들 때는 
 List<String> immutableList3 = Arrays.asList(arr); 
 이런식으로 생성한다.(Arrays.asList)
 
 hashcode 와 equals 를 오버라이딩해서 사용하면+
 문자 자체를 비교하게 된다.
 toString 사용시 toString입력 후 ctrl + space 누르면 쉽게 사용 가능
 컬렉션 내부저장시 '객체'로만 저장가능하다. 그렇게되면 기본타입(primitive)로 저장이 불가.
 그래서 포장클래스를 사용한다.(int > Integer, char > Character)
 
 박싱
 -기본타입 > 포장객체 변경
 언박싱
 -포장객체 > 기본타입 변경
 
 02.08
 
 -SourceTree-
 로컬로 올리는 작업은 Commit
 로컬에서 허브로 올리는 작업을 Push
 허브에서 로컬로 가져오는 작업을 Pull 이라고 한다.
 
 reset 은 되돌릴 수 있는데 이때 로컬에서 작업할 때만 사용해야한다.
 허브에 올린 뒤 리셋을 하는 순간 허브와 로컬의 내용이 달라지기 떄문에 conflict 가 발생한다.
 
 
  <프로그래밍의 오류를 처리하는 방식>
 * 1.C언어 방식 : 함수의 리턴값으로 성공/실패 오류 여부를 판단한다.
 * 성공/실패: true/false
 * 여러가지 case: 정수(-1,0,1,2...)
 * 2. C++언어 방식 : Exception 등장
 * 라이브러리로 제공되는 방식이 아니라서 개발자가 모두 직접 정의해야 함.
 *Exception은 
 나중에 추가된 문법이라 사용시 성능저하가 일어난다.
 * Java: 본격적으로 JDK메서드 내부에서 발생할 예외를 최대한 정의함.
 * 필요하면 사용자 추가 정의*/

/*예전에는 if 문으로
//프로그래밍 처리 -> 에러 확인 -> 연산 처리
 * 이렇게 프로그래밍을 하였다.
 * 
 * 입력 등에 예상치 못한 일이 많이 발생하므로
 * 프로그램에서 '오류 처리'가 프로그래밍 로직보다
 * 점점 커지는 현상이 일어났다.
 * => 코드의 가독성 저하
 * => 지저분해 보이는 현상
 * => 비용이 증가
 * 
 * 그래서 Exception 이라는 개념이 도입
 * =>try{
 *->프로그래밍 로직 설정
 * }catch{
 *->try 내에서 로직 실행 중 발생한 모든 에러를 처리하는 곳
 *}
 *
 *Java 는 JDK 라는 라이브러리를 제공하므로 직접 여러 모듈/클래스/메서드 설계했다.
 *이 설계과정에서 일어날 수 있는 모든 Error 에 대해서 '미리 정의된 Exception'을
 *제공함을써 개발자가 손쉽게 에러처리를 할 수 있도록 도와준다.
 *물론 모든 것을 예측할 수 없으므로 개발자가 직접 작성해야 할 때도 있다.
*/
하나의 코드에 예외가 여러개 생길 경우에는 catch문을 여러개를 써준다.
But !!! catch 문을 줄이고 싶다면 공통 부모를 선언하면 된다.(Exception)